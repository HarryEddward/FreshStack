name: Apply Docker Swarm Secrets to VPS

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Apply secrets to Swarm
        uses: appleboy/ssh-action@v1.0.3
        env:
          SSL_CERT: ${{ secrets.SSL_CERT }}
          SSL_KEY: ${{ secrets.SSL_KEY }}
          FRESH_SESSION_SECRET: ${{ secrets.FRESH_SESSION_SECRET }}
          JENKINS_SECRET_KEY: ${{ secrets.JENKINS_SECRET_KEY }}
          KEYCLOAK_CLIENT_BACKEND_SERVER_SECRET: ${{ secrets.KEYCLOAK_CLIENT_BACKEND_SERVER_SECRET }}
          POSTGRESQL_PASSWORD: ${{ secrets.POSTGRESQL_PASSWORD }}
          POSTGRESQL_USERNAME: ${{ secrets.POSTGRESQL_USERNAME }}
          SEAWEEDFS_S3_ACCESS_KEY: ${{ secrets.SEAWEEDFS_S3_ACCESS_KEY }}
          SEAWEEDFS_S3_SECRET_KEY: ${{ secrets.SEAWEEDFS_S3_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.STRIPE_PUBLISHABLE_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          envs: SSL_CERT,SSL_KEY,FRESH_SESSION_SECRET,JENKINS_SECRET_KEY,KEYCLOAK_CLIENT_BACKEND_SERVER_SECRET,POSTGRESQL_PASSWORD,POSTGRESQL_USERNAME,SEAWEEDFS_S3_ACCESS_KEY,SEAWEEDFS_S3_SECRET_KEY,STRIPE_PUBLISHABLE_KEY,STRIPE_SECRET_KEY
          script: |
            set -e
            
            SECRETS=(
              "SSL_CERT:ssl_cert"
              "SSL_KEY:ssl_key"
              "FRESH_SESSION_SECRET:fresh_session_secret"
              "JENKINS_SECRET_KEY:jenkins_secret_key"
              "KEYCLOAK_CLIENT_BACKEND_SERVER_SECRET:keycloak_client_backend_server_secret"
              "POSTGRESQL_PASSWORD:postgresql_password"
              "POSTGRESQL_USERNAME:postgresql_username"
              "SEAWEEDFS_S3_ACCESS_KEY:seaweedfs_s3_access_key"
              "SEAWEEDFS_S3_SECRET_KEY:seaweedfs_s3_secret_key"
              "STRIPE_PUBLISHABLE_KEY:stripe_publishable_key"
              "STRIPE_SECRET_KEY:stripe_secret_key"
            )
            
            STACKS=(
              "traefik:/home/ubuntu/FreshStack/traefik/docker-compose.yml"
              "postgresql:/home/ubuntu/FreshStack/postgresql/docker-compose.yml"
              "seaweedfs:/home/ubuntu/FreshStack/seaweedfs/docker-compose.yml"
            )
            
            RETRY_LIMIT=30
            WAIT_TIME=2
            
            remove_secret() {
              local secret_name=$1
              echo "Removing secret: ${secret_name}"
              sudo docker secret rm "${secret_name}" 2>/dev/null || true
            }
            
            wait_for_secret_removal() {
              local secret_name=$1
              local retries=$RETRY_LIMIT
              
              while sudo docker secret ls --format '{{.Name}}' | grep -q "^${secret_name}$"; do
                echo "Waiting for ${secret_name} to be removed..."
                sleep $WAIT_TIME
                retries=$((retries - 1))
                
                if [ $retries -le 0 ]; then
                  echo "ERROR: Timeout waiting for ${secret_name} removal"
                  exit 1
                fi
              done
            }
            
            create_secret() {
              local secret_name=$1
              local secret_value=$2
              
              echo "Creating secret: ${secret_name}"
              echo "${secret_value}" | sudo docker secret create "${secret_name}" -
              echo "Secret created: ${secret_name}"
            }
            
            get_secret_value() {
              local env_name=$1
              
              case "${env_name}" in
                SSL_CERT) echo "${SSL_CERT}" ;;
                SSL_KEY) echo "${SSL_KEY}" ;;
                FRESH_SESSION_SECRET) echo "${FRESH_SESSION_SECRET}" ;;
                JENKINS_SECRET_KEY) echo "${JENKINS_SECRET_KEY}" ;;
                KEYCLOAK_CLIENT_BACKEND_SERVER_SECRET) echo "${KEYCLOAK_CLIENT_BACKEND_SERVER_SECRET}" ;;
                POSTGRESQL_PASSWORD) echo "${POSTGRESQL_PASSWORD}" ;;
                POSTGRESQL_USERNAME) echo "${POSTGRESQL_USERNAME}" ;;
                SEAWEEDFS_S3_ACCESS_KEY) echo "${SEAWEEDFS_S3_ACCESS_KEY}" ;;
                SEAWEEDFS_S3_SECRET_KEY) echo "${SEAWEEDFS_S3_SECRET_KEY}" ;;
                STRIPE_PUBLISHABLE_KEY) echo "${STRIPE_PUBLISHABLE_KEY}" ;;
                STRIPE_SECRET_KEY) echo "${STRIPE_SECRET_KEY}" ;;
              esac
            }
            
            remove_stack() {
              local stack_name=$1
              
              echo "Removing stack: ${stack_name}"
              sudo docker stack rm "${stack_name}"
              
              while sudo docker stack ls --format '{{.Name}}' | grep -q "^${stack_name}$"; do
                echo "Waiting for ${stack_name} to be removed..."
                sleep 3
              done
              
              echo "Stack removed: ${stack_name}"
            }
            
            wait_for_services_shutdown() {
              echo "Waiting for all services to shut down completely..."
              sleep 5
              
              local retries=20
              while [ "$(sudo docker service ls -q | wc -l)" -gt 0 ]; do
                echo "Services still running, waiting..."
                sleep 3
                retries=$((retries - 1))
                
                if [ $retries -le 0 ]; then
                  echo "WARNING: Some services still running, continuing anyway"
                  break
                fi
              done
            }
            
            deploy_stack() {
              local stack_name=$1
              local compose_file=$2
              
              echo "Deploying stack: ${stack_name}"
              sudo docker stack deploy -c "${compose_file}" "${stack_name}"
              echo "Stack deployed: ${stack_name}"
            }
            
            echo "==> Step 1: Removing all stacks"
            
            for stack in "${STACKS[@]}"; do
              stack_name="${stack%%:*}"
              remove_stack "${stack_name}"
            done
            
            wait_for_services_shutdown
            
            echo "==> Step 2: Updating Docker Swarm secrets"
            
            for secret in "${SECRETS[@]}"; do
              env_name="${secret%%:*}"
              swarm_name="${secret##*:}"
              
              remove_secret "${swarm_name}"
              wait_for_secret_removal "${swarm_name}"
              
              secret_value=$(get_secret_value "${env_name}")
              create_secret "${swarm_name}" "${secret_value}"
            done
            
            echo "==> Step 3: Redeploying stacks"
            
            for stack in "${STACKS[@]}"; do
              stack_name="${stack%%:*}"
              compose_file="${stack##*:}"
              
              deploy_stack "${stack_name}" "${compose_file}"
            done
            
            echo "==> All secrets and stacks updated successfully"